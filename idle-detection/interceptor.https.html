<!DOCTYPE html>
<link rel="help" href="https://github.com/inexorabletash/idle-detection">
<title>Tests the Idle Detection API</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="mock.js"></script>
<script>
'use strict';

promise_test(async t => {
  // Basic test that expects navigator.idle.query() to call internally
  // addMonitor, which in turn will return an ACTIVE state.
  await expect(addMonitor).andReturn((threshold, monitorPtr) => {
      return Promise.resolve({state: IdleState.ACTIVE});
  });

  let status = await navigator.idle.query({threshold: 10});

  assert_equals(status.state, "active");
}, 'query()');

promise_test(async t => {
  // Verifies that an event is thrown when a change of state from IDLE to ACTIVE
  // is detected.
  await expect(addMonitor).andReturn((threshold, monitorPtr) => {
      t.step_timeout(() => {
        monitorPtr.update(IdleState.IDLE);
      }, 0);
      return Promise.resolve({state: IdleState.ACTIVE});
    });

  let monitor = await navigator.idle.query({threshold: 10});

  await new EventWatcher(t, monitor, ["change"]).wait_for("change");

  assert_equals(monitor.state, "idle");
}, 'updates once');


promise_test(async t => {
  // Simulates the user being active, going idle and then going back active
  // again.
  await expect(addMonitor).andReturn((threshold, monitorPtr) => {
      // Updates the client once with the user idle.
      t.step_timeout(() => {
        monitorPtr.update(IdleState.IDLE);
      }, 0);
      // Updates the client a second time with the user active.
      t.step_timeout(() => {
        monitorPtr.update(IdleState.ACTIVE);
      }, 1);
      return Promise.resolve({state: IdleState.ACTIVE});
    });

  let monitor = await navigator.idle.query({threshold: 10});

  let watcher = new EventWatcher(t, monitor, ["change"]);

  // waits for the first event.
  await watcher.wait_for("change");
  assert_equals(monitor.state, "idle");

  // waits for the second event.
  await watcher.wait_for("change");
  assert_equals(monitor.state, "active");
}, 'updates twice');

promise_test(async t => {
  // Simulates a locked screen.
  await expect(addMonitor).andReturn((threshold, monitorPtr) => {
      return Promise.resolve({state: IdleState.LOCKED});
    });

  let monitor = await navigator.idle.query({threshold: 10});

  assert_equals(monitor.state, "locked");
}, 'locked screen');

promise_test(async t => {
  // Simulates the service becoming unavailable.
  await expect(addMonitor).andReturn((threshold, monitorPtr) => {
      return new Promise(function(resolve, reject) {
        // leave the renderer deliberately hanging by not resolve()-ing.
      });
    });

  let error = new Promise(function(resolve, reject) {
    navigator.idle.query({threshold: 10})
      .then((e) => {reject("unexpected response :(")})
      .catch((e) => {resolve(e.message)});
  });

  // simulates what happens when the service is unavailable.
  close();

  assert_equals(await error, "Idle detection not available");
}, "service unavailable");
</script>